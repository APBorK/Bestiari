Введение:
Обратите внимание: если вы ищете старую документацию для Zenject, вы можете найти ее здесь: Zenject 3.x, Zenject 4.x и Zenject 5.x.

Zenject — это легкий высокопроизводительный фреймворк внедрения зависимостей, созданный специально для Unity 3D (однако его можно использовать и за пределами Unity).
Его можно использовать для превращения вашего приложения в набор слабо связанных частей с сильно сегментированными обязанностями. Затем Zenject может склеивать части вместе во многих различных конфигурациях, чтобы вы могли легко писать, повторно использовать, рефакторить и тестировать свой код масштабируемым и чрезвычайно гибким способом.

Протестировано в Unity 3D на следующих платформах:

-ПК/Mac/Linux
-iOS
-Андроид
-WebGL
-PS4 (с серверной частью IL2CPP)
-Магазин Windows (включая 8.1, Phone 8.1, Universal 8.1 и Universal 10 — как серверную часть .NET, так и IL2CPP)

IL2CPP поддерживается, однако есть некоторые подводные камни — подробности см. здесь.

Этот проект с открытым исходным кодом.
Для общего устранения неполадок / поддержки, пожалуйста, отправьте сообщение в переполнение стека, используя тег «zenject», или опубликуйте сообщение в группе zenject google.
Или, если вы нашли ошибку, вы также можете создать проблему на [странице github] https://github.com/modesttree/Zenject) или запрос на вытягивание, если у вас есть исправление/расширение.
Существует также чат Gitter, к которому вы можете присоединиться для обсуждения в реальном времени.

Функции
1.Injection
-Поддерживает как обычные классы C#, так и MonoBehaviours.
-Constructor injection
-Field injection
-Property injection
-Method injection
2.Условная привязка (например, по типу, по имени и т. д.)
3.Дополнительные зависимости
4.Поддержка создания объектов после инициализации с использованием фабрик
5.Вложенные контейнеры, также известные как субконтейнеры
6.Внедрение в разные сцены Unity для передачи информации из одной сцены в другую
7.Родительская сцена, позволяющая одной сцене наследовать привязки от другой.
8.Поддержка глобальных привязок всего проекта для добавления зависимостей для всех сцен.
9.Привязка на основе соглашения, основанная на имени класса, пространстве имен или любых других критериях.
10.Возможность проверки графов объектов во время редактирования (включая динамические графы объектов, созданные с помощью фабрик)
11.Автоматическая привязка компонентов в сцене с помощью компонента ZenjectBinding.
12.Auto-Mocking с использованием библиотеки Moq
13.Встроенная поддержка пулов памяти
14.Поддержка шаблона декоратора с использованием привязок декоратора
15.Поддержка автоматического сопоставления открытых универсальных типов.
16.Встроенная поддержка модульного тестирования, интеграционных тестов и тестов сцены.
17.Своевременная инъекция с использованием конструкции LazyInject<>
18.Поддержка нескольких потоков для разрешения/создания экземпляров
19.Поддержка «запекания отражений» для полного устранения дорогостоящих операций отражения путем прямого изменения сгенерированных сборок.
20.Автоматическое внедрение игровых объектов с помощью компонента ZenAutoInjecter

Установка версии GitHub (последняя на дату)
GitHub выпускает пакет Unity Unity

Вы можете установить Zenject любым из следующих способов

1.Со страницы релизов Здесь вы можете выбрать одно из следующего:

-Пакет Zenject-WithAsteroidsDemo.vX.X.unity — Это эквивалентно тому, что вы найдете в Asset Store, и содержит образцы игр «Asteroids» и «SpaceFighter» как часть пакета. Здесь находится весь исходный код Zenject.
-Пакет Zenject.vX.X.unity — то же, что и выше, за исключением примеров проектов.
-Zenject-NonUnity.vX.X.zip — Используйте это, если хотите использовать Zenject вне Unity (например, как обычный проект C#).

2.Из магазина активов Unity

-Обычно это должно быть то же самое, что вы найдете в разделе «Релизы», но также может быть немного устаревшим, поскольку в магазине Unity Asset Store иногда может потребоваться около недели для проверки представленных материалов.

3.Филиал УПМ
-Эта опция является запросом функции. Пакет будет выпущен, когда Unity будет готов. Unity не дает никакой информации о статусе разработки. Но ожидание в первом или втором выпуске 2020 года.
-Если вы не можете ждать. Есть альтернатива. Но вам понадобится расширение Unity, которое можно найти здесь. И пакет нашел здесь.

4.Из источника
-Обратите внимание, что после синхронизации репозитория git вам потребуется собрать Zenject-Usage.dll, создав решение в AssemblyBuild\Zenject-usage\Zenject-usage.sln. Или, если вы предпочитаете, вы можете вместо этого получить Zenject-Usage.dll из раздела «Релизы».
-Затем вы можете скопировать каталог UnityProject/Assets/Plugins/Zenject в свой собственный проект Unity3D.

Обратите внимание, что при импорте Zenject в ваш проект Unity вы можете снять отметку с любой папки в папке OptionalExtras в тех случаях, когда вы не хотите ее включать, или если вам просто нужны основные функции Zenject, вы можете снять отметку со всей директории OptionalExtras.

История
Unity — фантастический игровой движок, однако подход, который рекомендуется использовать новым разработчикам, не подходит для написания больших, гибких или масштабируемых кодовых баз. В частности, способ, которым Unity по умолчанию управляет зависимостями между различными игровыми компонентами, часто может быть неудобным и подверженным ошибкам.
Этот проект был начат, потому что в то время для Unity не существовало DI-фреймворков, и, использовав DI-фреймворки вне Unity (например, Ninject) и увидев преимущества, я почувствовал, что важно это исправить.

Наконец, я просто скажу, что если у вас нет опыта работы с DI-фреймворками и вы пишете объектно-ориентированный код, то поверьте мне,
вы будете благодарить меня позже! Как только вы научитесь правильно писать слабосвязанный код с использованием DI, пути назад уже не будет.

Документация
Документация Zenject разделена на следующие разделы. Он разделен на две части (Введение и Расширенный), чтобы вы могли приступить к работе как можно быстрее. Я бы порекомендовал хотя бы бегло просмотреть раздел «Введение», прежде чем начать.
но затем не стесняйтесь прыгать в расширенном разделе по мере необходимости

Еще одна отличная отправная точка — посмотреть этот сериал на YouTube о zenject, созданный Infallible Code.

Вам также может быть полезно поиграть с предоставленными примерами проектов (которые вы можете найти, открыв Zenject/OptionalExtras/SampleGame1 или Zenject/OptionalExtras/SampleGame2).
.

Если вы ветеран DI, возможно, стоит взглянуть на шпаргалку внизу этой страницы, которая должна дать вам представление о синтаксисе, и это может быть все, что вам нужно для начала.
Тесты также могут быть полезны для демонстрации использования каждой конкретной функции (их можно найти в Zenject/OptionalExtras/UnitTests и Zenject/OptionalExtras/IntegrationTests).

Также см. раздел «Дополнительная литература» для некоторых внешних руководств по zenject, представленных в другом месте.

Теория
Далее следует общий обзор внедрения зависимостей с моей точки зрения. Тем не менее, он остается легким, поэтому я настоятельно рекомендую искать другие ресурсы для получения дополнительной информации по этому вопросу, поскольку есть много других людей (часто с лучшими способностями к письму), которые написали о лежащей в его основе теории.
При написании отдельного класса для достижения некоторой функциональности ему, вероятно, потребуется взаимодействовать с другими классами в системе для достижения своих целей. Один из способов сделать это — заставить класс сам создавать свои зависимости, вызывая конкретные конструкторы:

public class Foo
{
    ISomeService _service;

    public Foo()
    {
        _service = new SomeService();
    }

    public void DoSomething()
    {
        _service.PerformTask();
       … 
    }
}

Это хорошо работает для небольших проектов, но по мере роста вашего проекта становится громоздким. Класс Foo тесно связан с классом SomeService. Если позже мы решим, что хотим использовать другую конкретную реализацию, нам придется вернуться в класс Foo, чтобы изменить ее.

Подумав об этом,
часто приходишь к выводу, что в конечном счете Foo не стоит утруждать себя деталями выбора конкретной реализации сервиса. Все, о чем должен заботиться Foo, — это выполнение своих конкретных обязанностей. Пока служба выполняет абстрактный интерфейс, требуемый Foo, Foo счастлив. Тогда наш класс становится:

public class Foo
{
    ISomeService _service;

    public Foo(ISomeService service)
    {
        _service = service;
    }

    public void DoSomething()
    {
        _service.PerformTask();
        ...
    }
}

Это лучше, но теперь любой класс, создающий Foo (назовем его Bar), имеет проблему заполнения дополнительных зависимостей Foo:

public class Bar
{
    public void DoSomething()
    {
        var foo = new Foo(new SomeService());
        foo.DoSomething();
        ...
    }
}

И класс Bar, вероятно, также не очень заботится о том, какую конкретную реализацию SomeService Foo использует. Поэтому мы снова подталкиваем зависимость вверх:

public class Bar
{
    ISomeService _service;

    public Bar(ISomeService service)
    {
        _service = service;
    }

    public void DoSomething()
    {
        var foo = new Foo(_service);
        foo.DoSomething();
        ...
    }
}

Итак, мы считаем, что полезно возлагать ответственность за принятие решения о том, какие конкретные реализации каких классов использовать, все дальше и дальше в «графе объектов» приложения. Доводя это до крайности, мы достигаем точки входа приложения, в которой все зависимости должны быть удовлетворены, прежде чем что-то начнется.
Термин «внедрение зависимостей» для этой части приложения называется «корнем композиции». Обычно это выглядело бы так:

var service = new SomeService();
var foo = new Foo(service);
var bar = new Bar(service);
var qux = new Qux(bar);

.. etc.

Фреймворки DI, такие как Zenject, просто помогают автоматизировать этот процесс создания и передачи всех этих конкретных зависимостей, поэтому вам не нужно явно делать это самостоятельно, как в приведенном выше коде.

Заблуждения
Существует много неправильных представлений о DI из-за того, что поначалу может быть сложно полностью уложиться в голове. Потребуется время и опыт, прежде чем он полностью «щелкнет».

Как показано в приведенном выше примере, DI можно использовать для простой замены различных реализаций данного интерфейса (в примере это был ISomeService). Однако,
это только одно из многих преимуществ, которые предлагает DI.

Более важным является тот факт, что использование фреймворка внедрения зависимостей, такого как Zenject, позволяет вам легче следовать «принципу единой ответственности». Позволив Zenject заботиться о подключении классов,
сами классы могут просто сосредоточиться на выполнении своих конкретных обязанностей.

Еще одна распространенная ошибка, которую совершают новички в DI, заключается в том, что они извлекают интерфейсы из каждого класса и используют эти интерфейсы везде, а не используют класс напрямую. Цель состоит в том, чтобы сделать код более слабо связанным,
поэтому разумно думать, что привязка к интерфейсу лучше, чем привязка к конкретному классу. Однако в большинстве случаев различные обязанности приложения реализуются одними конкретными классами, поэтому использование интерфейсов в этих случаях просто добавляет ненужные накладные расходы на обслуживание. Также,
конкретные классы уже имеют интерфейс, определенный их открытыми членами. Вместо этого хорошим практическим правилом является создание интерфейсов только тогда, когда класс имеет более одной реализации или в случаях, когда вы намерены иметь несколько реализаций в будущем (кстати, это известно как принцип повторного использования абстракции).

Другие преимущества включают в себя:
-Возможность рефакторинга. Когда код слабо связан, как в случае правильного использования DI, вся кодовая база гораздо более устойчива к изменениям. Вы можете полностью изменить части базы кода, не причиняя вреда другим частям.
-Поощряет модульный код. При использовании среды внедрения зависимостей вы, естественно, будете следовать передовым методам проектирования., потому что это заставляет вас думать об интерфейсах между классами.
-Тестируемость. Написание автоматических модульных тестов или тестов, управляемых пользователем, становится очень простым, потому что это просто вопрос написания другого «корня композиции», который связывает зависимости по-другому. Хотите протестировать только одну подсистему? Просто создайте новый корень композиции.Zenject также имеет некоторую поддержку для предотвращения дублирования кода в самом корне композиции (с помощью установщиков - описано ниже).
Также см. здесь и здесь для дальнейшего обсуждения и обоснования использования инфраструктуры внедрения зависимостей.

Introduction to Zenject API
Hello World Example
using Zenject;
using UnityEngine;
using System.Collections;

public class TestInstaller : MonoInstaller
{
    public override void InstallBindings()
    {
        Container.Bind<string>().FromInstance("Hello World!");
        Container.Bind<Greeter>().AsSingle().NonLazy();
    }
}

public class Greeter
{
    public Greeter(string message)
    {
        Debug.Log(message);
    }
}

Вы можете запустить этот пример, выполнив следующие действия:

-Создайте новую сцену в Unity
-Щелкните правой кнопкой мыши на вкладке «Иерархия» и выберите Zenject -> Контекст сцены.
-Щелкните правой кнопкой мыши папку на вкладке «Проект» и выберите «Создать» -> «Zenject» -> «MonoInstaller». Назовите его TestInstaller.cs
-Добавьте свой скрипт TestInstaller на сцену (как собственный GameObject или на тот же GameObject, что и SceneContext, это не имеет значения)
-Добавьте ссылку на свой TestInstaller в свойства SceneContext, добавив новую строку в инспекторе свойства «Установщики» (нажмите кнопку +), а затем перетащите в нее TestInstaller
-Откройте TestInstaller и вставьте в него приведенный выше код.
-Проверьте свою сцену, выбрав Edit -> Zenject -> Validate Current Scene или нажав CTRL+ALT+V. (обратите внимание, что этот шаг необязателен, но является хорошей практикой)
-Бегать
-Также обратите внимание, что вы можете использовать сочетание клавиш CTRL+SHIFT+R, чтобы «проверить, а затем запустить».
-Проверка обычно выполняется достаточно быстро, чтобы не добавлять заметных накладных расходов для запуска вашей игры, а когда она обнаруживает ошибки, итерация выполняется намного быстрее, поскольку вы избегаете времени запуска.
-Наблюдайте за консолью единства для вывода
-SceneContext MonoBehaviour — это точка входа приложения,
где Zenject устанавливает все различные зависимости перед запуском вашей сцены. Чтобы добавить контент в вашу сцену Zenject, вам нужно написать то, что в Zenject называется «Установщик», который объявляет все зависимости и их отношения друг с другом.
-Все зависимости, помеченные как «NonLazy», автоматически создаются после запуска установщиков, поэтому класс Greeter, который мы добавили выше, создается при запуске. Если это еще не имеет для вас смысла, продолжайте читать!

Injection
Существует множество различных способов объявления зависимостей от контейнера, которые описаны в следующем разделе. Есть также несколько способов внедрить эти зависимости в ваши классы. Это:

1 - Constructor Injection

public class Foo
{
    IBar _bar;

    public Foo(IBar bar)
    {
        _bar = bar;
    }
}


2 - Field Injection

public class Foo
{
    [Inject]
    IBar _bar;
}

Внедрение поля происходит сразу после вызова конструктора. Все поля, отмеченные атрибутом [Inject], просматриваются в контейнере и получают значение. Обратите внимание, что эти поля могут быть закрытыми или общедоступными, и внедрение все равно будет происходить.

3 - Property Injection

public class Foo
{
    [Inject]
    public IBar Bar
    {
        get;
        private set;
    }
}

Внедрение свойств работает так же, как внедрение полей, за исключением того, что оно применяется к свойствам C#. Как и поля, в этом случае сеттер может быть частным или общедоступным.

4 - Method Injection

public class Foo
{
    IBar _bar;
    Qux _qux;

    [Inject]
    public void Init(IBar bar, Qux qux)
    {
        _bar = bar;
        _qux = qux;
    }
}

Метод Inject Injection работает очень похоже на внедрение конструктора.

Обратите внимание на следующее:

-Методы внедрения являются рекомендуемым подходом для MonoBehaviours, поскольку MonoBehaviours не может иметь конструкторов.Методов ввода может быть сколько угодно. В этом случае они вызываются в порядке от базового класса к производному классу.
-Это может быть полезно, чтобы избежать необходимости перенаправлять многие зависимости от производных классов в базовый класс через параметры конструктора, а также гарантировать, что методы внедрения базового класса завершатся первыми, точно так же, как работают конструкторы.
-Методы внедрения вызываются после всех других типов внедрения.Он разработан таким образом, чтобы эти методы можно было использовать для выполнения логики инициализации, которая может использовать введенные поля или свойства. Также обратите внимание, что вы можете оставить список параметров пустым, если вы просто хотите выполнить некоторую логику инициализации.
-Вы можете с уверенностью предположить, что зависимости, которые вы получаете с помощью методов внедрения, сами по себе уже были внедрены (единственным исключением является случай, когда у вас циклические зависимости). Это может быть важно, если вы используете методы ввода для выполнения базовой инициализации.так как в этом случае вам может потребоваться инициализация данных зависимостей
-Однако обратите внимание, что обычно не рекомендуется использовать методы внедрения для логики инициализации. Часто вместо этого лучше использовать методы IInitializable.Initialize или Start(), так как это позволит сначала создать весь исходный граф объектов.


Рекомендации
Лучшей практикой является предпочтение внедрения конструктора/метода по сравнению с внедрением поля/свойства.

-Внедрение конструктора заставляет зависимость разрешаться только один раз, при создании класса, что обычно и требуется.В большинстве случаев вы не хотите раскрывать общедоступное свойство для ваших первоначальных зависимостей, потому что это предполагает, что оно открыто для изменения.
-Внедрение конструктора гарантирует отсутствие циклических зависимостей между классами, что, как правило, плохо.Zenject допускает циклические зависимости при использовании других типов инъекций, таких как метод/поле/свойство.
-Внедрение конструктора/метода более переносимо для случаев, когда вы решаете повторно использовать код без инфраструктуры DI, такой как Zenject.Вы можете сделать то же самое с общедоступными свойствами, но это более подвержено ошибкам (проще забыть инициализировать одно поле и оставить объект в недопустимом состоянии)
-Наконец, внедрение конструктора/метода позволяет понять, каковы все зависимости класса, когда другой программист читает код.Они могут просто посмотреть список параметров метода. Это также хорошо, потому что будет более очевидно, когда класс имеет слишком много зависимостей и поэтому должен быть разделен (поскольку его список параметров конструктора начнет казаться длинным).

Регистрация сопоставлений в контейнере внедрения зависимостей

Ядром инфраструктуры внедрения зависимостей является контейнер внедрения зависимостей. В простейшей форме это объект, содержащий словарь, содержащий все регистрации. В этом разделе мы рассмотрим часть «зарегистрировать новое сопоставление». В Zenject это называется привязкой. Поскольку он создает привязку между абстракцией к конкретному типу.

Связывание 
Каждый фреймворк внедрения зависимостей в конечном счете является просто фреймворком для привязки типов к экземплярам.

В Zenject сопоставление зависимостей выполняется путем добавления привязок к чему-то, что называется контейнером. Затем контейнер должен «знать», как создавать все экземпляры объектов в вашем приложении, рекурсивно разрешая все зависимости для данного объекта.
Когда контейнеру предлагается создать экземпляр заданного типа, он использует отражение C#, чтобы найти список аргументов конструктора и все поля/свойства, отмеченные атрибутом [Inject]. Затем он пытается разрешить каждую из этих обязательных зависимостей, которые он использует для вызова конструктора и создания нового экземпляра.
Поэтому каждое приложение Zenject должно сообщать контейнеру, как разрешать каждую из этих зависимостей, что делается с помощью команд Bind. Например, для следующего класса:

public class Foo
{
    IBar _bar;

    public Foo(IBar bar)
    {
        _bar = bar;
    }
}

Вы можете подключить зависимости для этого класса следующим образом:

Container.Bind<Foo>().AsSingle();
Container.Bind<IBar>().To<Bar>().AsSingle();

Это говорит Zenject, что каждый класс, требующий зависимости типа Foo, должен использовать один и тот же экземпляр, который он будет автоматически создавать при необходимости. И точно так же любому классу, которому требуется интерфейс IBar (например, Foo), будет предоставлен один и тот же экземпляр типа Bar.

Полный формат команды привязки следующий.
Обратите внимание, что в большинстве случаев вы не будете использовать все эти методы и что все они имеют логические значения по умолчанию, если они не указаны.

Container.Bind<ContractType>()
    .WithId(Identifier)
    .To<ResultType>()
    .FromConstructionMethod()
    .AsScope()
    .WithArguments(Arguments)
    .OnInstantiated(InstantiatedCallback)
    .When(Condition)
    .(Copy|Move)Into(All|Direct)SubContainers()
    .NonLazy()
    .IfNotBound();

Где:

1.ContractType = Тип, для которого вы создаете привязку.

-Это значение будет соответствовать типу вводимого поля/параметра.

2.ResultType = Тип для привязки.

-По умолчанию: тип контракта
-Этот тип должен либо быть равен ContractType, либо быть производным от ContractType. Если не указано, предполагается ToSelf(),это означает, что ResultType будет таким же, как ContractType. Это значение будет использоваться тем, что задано как ConstructionMethod, для получения экземпляра этого типа.

3.Идентификатор = значение, используемое для уникальной идентификации привязки. В большинстве случаев этим можно пренебречь, т.но может быть весьма полезным в тех случаях, когда вам нужно различать несколько привязок с одним и тем же типом контракта. Подробнее см. здесь.

4.ConstructionMethod = метод, с помощью которого создается/извлекается экземпляр ResultType. Подробнее о различных методах строительства см. в этом разделе.

-По умолчанию: из нового()
-Примеры: напр. ФромГеттер,FromMethod, FromResolve, FromComponentInNewPrefab, FromSubContainerResolve, FromInstance и т. д.

5.Scope = Это значение определяет, как часто (и используется ли вообще) сгенерированный экземпляр повторно для нескольких внедрений.

-По умолчанию: AsTransient. Однако обратите внимание, что не все привязки имеют значение по умолчанию, поэтому, если оно не указано, будет выдано исключение.Привязки, не требующие явной установки области действия, — это любые привязки с методом построения, который представляет собой поиск, а не создание нового объекта с нуля (например, FromMethod, FromComponentX, FromResolve и т. д.).

-Это может быть одно из следующих:

a.AsTransient — вообще не будет повторно использовать экземпляр. Каждый раз, когда запрашивается ContractType,DiContainer снова выполнит данный метод построения
b.AsCached — будет повторно использовать один и тот же экземпляр ResultType каждый раз, когда запрашивается ContractType, который будет лениво генерироваться при первом использовании.
c.AsSingle — точно такой же, как AsCached, за исключением того, что он иногда генерирует исключения, если уже существует привязка для ResultType.Это просто способ убедиться, что данный ResultType уникален внутри контейнера. Однако обратите внимание, что это гарантирует только один экземпляр в данном контейнере, а это означает, что использование AsSingle с той же привязкой в ​​подконтейнере может создать второй экземпляр.
-В большинстве случаев,вы, вероятно, захотите просто использовать AsSingle, однако AsTransient и AsCached также имеют свое применение.

5.Аргументы = список объектов для использования при создании нового экземпляра типа ResultType. Это может быть полезно в качестве альтернативы добавлению других привязок для аргументов в форме Container.BindInstance(arg).WhenInjectedInto<ResultType>()

6.InstantiatedCallback = В некоторых случаях полезно иметь возможность настроить объект после его создания. В частности, при использовании сторонней библиотеки может потребоваться изменить несколько полей в одном из ее типов. В этих случаях вы можете передать метод OnInstantiated, который может настроить вновь созданный экземпляр. Например:

Container.Bind<Foo>().AsSingle().OnInstantiated<Foo>(OnFooInstantiated);

void OnFooInstantiated(InjectContext context, Foo foo)
{
    foo.Qux = "asdf";
}

Или, что то же самое:

Container.Bind<Foo>().AsSingle().OnInstantiated<Foo>((ctx, foo) => foo.Bar = "qux");

Обратите внимание, что вы также можете привязать пользовательскую фабрику с помощью FromFactory, которая напрямую вызывает Container.InstantiateX, прежде чем настраивать ее для того же эффекта, но в некоторых случаях OnInstantiated может быть проще.

Условие = условие, которое должно быть истинным для выбора этой привязки. Подробнее см. здесь.
(Копировать|Переместить)В(Все|Прямые)Подконтейнеры = Это значение можно игнорировать для 99% пользователей. Его можно использовать для автоматического наследования привязки подконтейнерами. Например, если у вас есть класс Foo и вы хотите, чтобы уникальный экземпляр Foo автоматически размещался в контейнере и каждом подконтейнере, вы можете добавить следующую привязку:
Container.Bind<Foo>().AsSingle().CopyIntoAllSubContainers()
Другими словами, результат будет эквивалентен копированию и вставке оператора Container.Bind<Foo>().AsSingle() в программу установки для каждого подконтейнера.

Или, если вам нужен только Foo в подконтейнерах, а не в текущем контейнере:

Container.Bind<Foo>().AsSingle().
Переместить во все подконтейнеры()
Или, если вы хотите, чтобы Foo был только в непосредственном дочернем подконтейнере, а не в подконтейнерах этих подконтейнеров:

Container.Bind<Foo>().AsSingle().MoveIntoDirectSubContainers()
NonLazy = Обычно экземпляр ResultType создается только при первом использовании привязки (он же «ленивый»). Однако при использовании NonLazy
ResultType будет немедленно создан при запуске.

IfNotBound = Когда это добавлено к привязке и уже есть привязка с данным типом контракта + идентификатором, эта привязка будет пропущена.

Construction Methods